---
title: 函数的单例模式
date: 2023-05-13
tags:
  - 前端的那些事儿
categories:
  - 前端的那些事儿
permalink: /20230513
---

## 单例模式

一般在前端实现单例模式，大多数都会使用类去实现，因为类的实现，看起来比较简单，下面是一个简单的例子。

```js
class Foo {
  static instance;
  static init() {
    if (!this.instance) this.instance = new Foo();
    return this.instance;
  }
  constructor() {}
}

// 将单例实例化 并暴露出去
export default Foo.init();
```

::: tip
如此，我们就实现了简单的单例模式，并且在其他文件引入的时候已经是实例化过一次的了，或者交由用户者自行调用 init 也是可以的
:::

## 函数实现

而在函数的实现上，其实本身类就是函数的某种抽象，如果去掉这个 new 的话，单纯用函数又是怎么做的呢？

```ts
let ipcMainInstance;
export default () => {
  const init = () => {
    return {
      name: "phy",
      hobby: "play games"
    };
  };

  return () => {
    if (!ipcMainInstance) {
      ipcMainInstance = init();
    }
    return ipcMainInstance;
  };
};
```

使用

```ts
const ipcInit = createIpc();
ipcInit();
```

::: tip
因为我们使用的是二阶函数进行 init，所以写法上是二次调用才是 init，每个人的设计写法不一样。
:::

然而这种写法上，每次都要写一个 init 方法进行单例实例化的包裹，这明显是一个重复工作，我们是否可以将 init 方法独立成一个函子，让他帮我们自动将我们传进去的函数进行处理，返回来的就是一个单例模式的函数呢？

## 抽象单例模式函子

```ts
// 非void返回值
type NonVoidReturn<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R extends void
    ? never
    : T
  : any;

/**
 * 创建单例模式的函子
 * @param {function} fn
 * @returns {any} fn调用的返回值 必须得有return 可推断
 */
const createSgp = <T extends (...args: any) => any>(fn: NonVoidReturn<T>) => {
  let _instance: undefined | ReturnType<T>;

  return () => {
    if (!_instance) {
      _instance = fn();
    }
    return _instance;
  };
};

export default createSgp;
```

在使用上

```ts
import createSgp from "./createSgp";

const useAuto = () => {
  let count = 0;

  const setCount = (num: number) => {
    count = num;
  };

  const getCount = () => count;

  return {
    getCount,
    setCount
  };
};

// 将其处理成单例模式 并且暴露出去
export default createSgp(useAuto);
```

::: tip
如此我们就完成了单例模式的包裹处理，并且是一个单例模式的函数了。有一点需要注意的是，因为在我们 createSgp 单例装载的时候，我们拿回来的是一个对象其实，其实跟类还是不对等的，也就导致在获取固定值的时候，不能单单 return 固定值，应该用函数去 get，就像上面的 getCount，如果 return count，那么这个 count 永远都是初始值来的。
:::
