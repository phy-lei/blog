(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{515:function(s,t,n){"use strict";n.r(t);var a=n(2),e=Object(a.a)({},(function(){var s=this,t=s._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[s._v("#")]),s._v(" 背景")]),s._v(" "),t("p",[s._v("在上一期，已经完成了taro-solid的官方插件，目前的状态已经合并进去了"),t("a",{attrs:{href:"https://github.com/NervJS/taro/pulls?q=is%3Apr+is%3Aclosed+author%3Aphy-lei",target:"_blank",rel:"noopener noreferrer"}},[s._v("pr"),t("OutboundLink")],1),s._v("，只要等待taro4.x发布就能够享用，但是像react/vue都有其相对应的taro的小程序组件库，而solid还没有，所以就需要做一个类似京东风格"),t("a",{attrs:{href:"https://nutui.jd.com/taro/vue/4x/#/zh-CN/guide/intro",target:"_blank",rel:"noopener noreferrer"}},[s._v("nutui"),t("OutboundLink")],1),s._v("的组件库，仓库在这👉"),t("a",{attrs:{href:"https://github.com/phy-lei/nutui-solid-next",target:"_blank",rel:"noopener noreferrer"}},[s._v("nutui-solid-next"),t("OutboundLink")],1)]),s._v(" "),t("h1",{attrs:{id:"目录结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[s._v("#")]),s._v(" 目录结构")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\n├── eslint.config.js //eslint配置\n├── package.json\n├── packages\n│   ├── config.json //组件/nav配置\n│   ├── icons-solid //h5 icon图标\n│   ├── icons-solid-taro //taro icon图标\n│   ├── nutui-solid //组件库\n│   └── nutui-solid-site //组件库文档/官网\n├── pnpm-lock.yaml\n├── pnpm-workspace.yaml\n└── tsconfig.json\n")])])]),t("p",[s._v("目前的L2目录结构有这些，主要需要做的是在nutui-solid目录下建设组件库，而config.json文件主要是一份nutui-solid下components目录下所有的组件，但是目前"),t("strong",[s._v("每次新增一个组件文件，都需要在config.json中手动添加对应的组件信息")]),s._v("，这种方式不够自动化，后续会考虑使用脚本进行自动化写入。")]),s._v(" "),t("h1",{attrs:{id:"nutui-solid-site"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nutui-solid-site"}},[s._v("#")]),s._v(" nutui-solid-site")]),s._v(" "),t("p",[s._v("文档的官网设计，我没再使用传统spa框架，而是使用了Astro meta框架，为什么呢？因为我发现无论是vue/react，他们都是使用各自的框架去实现这个文件官网，而文档官网很多都是需要md/mdx来输出编译的，其实他们的展示是一样的，但是由于切换了一个框架，实现就大相径庭。还有一个重要问题在于solid的md编译器是依赖于其solid-start的框架实现，如果我选择了这个，也是不能够统一。\n而Astro有一个很重要的东西，是他拥有许多ui适配器，vue/react/svelte/solid等等都有。看看目前文档官网的ui设计")]),s._v(" "),t("p",[t("img",{attrs:{src:s.$withBase("/assets/20240626/01.png"),alt:""}})]),s._v(" "),t("p",[s._v("除了中间的docs区域，其他都是固定形态的，这方面可以用Astro的形式建设，而docs区域，让其成为孤岛，加载对应的adapter就好了，这也是Astro的"),t("strong",[s._v("群岛")]),s._v("架构。")]),s._v(" "),t("blockquote",[t("p",[s._v("在之后如果还需要新增nutui的组件库，可以直接复用这套文档架构，新增个适配器，比较简单进行迁移")])]),s._v(" "),t("blockquote",[t("p",[s._v("不过目前架构是ssr模式，其实也可以改为ssg，但是写的东西要多很多，暂定用ssr模式。如有需要再进行改动。")])]),s._v(" "),t("h2",{attrs:{id:"组件文档的目录结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件文档的目录结构"}},[s._v("#")]),s._v(" 组件文档的目录结构")]),s._v(" "),t("p",[s._v("在nutui-solid-site下，我把文档都从组件侧迁移到这里统一管理了，因为这里有用到mdx，而mdx的组件是在改目录下，所以就放这里面管理了。")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\n├── astro.config.mjs\n├── package.json\n├── pnpm-lock.yaml\n├── public\n│   └── favicon.svg\n├── src\n│   ├── assets\n│   │   ├── images\n│   │   ├── locale\n│   │   └── styles\n│   ├── components\n│   │   ├── CodeBlock.astro\n│   │   ├── Demo.astro\n│   │   ├── DemoBlock.tsx\n│   │   ├── demoblock.scss\n│   │   └── nav\n│   ├── config\n│   │   └── env.ts\n│   ├── content\n│   │   ├── config.ts\n│   │   ├── en //英文h5文档\n│   │   ├── taro //taro文档\n│   │   ├── zh-cn //中文h5文档\n│   │   └── zh-tw //tw h5文档\n│   ├── env.d.ts\n│   ├── layouts\n│   │   ├── Layout.astro\n│   │   └── MobileLayout.astro\n│   ├── pages\n│   │   ├── demo  //组件的demo preview 路由\n│   │   ├── h5 //h5的文档路由\n│   │   └── taro //taro的文档路由\n│   └── utils\n│       └── index.ts\n└── tsconfig.json\n")])])]),t("p",[s._v("在content的目录结构下，md的文档都放这里面，多语言跟taro的，路由就是在pages下面了，pages的路由跟contens有关联，主要采用的是Astro的那一套内容集合。")]),s._v(" "),t("h1",{attrs:{id:"nutui-solid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nutui-solid"}},[s._v("#")]),s._v(" nutui-solid")]),s._v(" "),t("p",[s._v("目录结构：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\n├── global.d.ts\n├── package.json\n├── plugin\n│   └── vite-plugin-solid.ts //cv的vite-plugin-solid，babel需要用我们的babel\n├── scripts //一些命令脚本\n│   └── generate-themes.cjs\n├── src\n│   ├── components //组件\n│   │   ├── button\n│   │   └── nutui.solid.build.ts //组件的暴露入口文件\n│   ├── styles\n│   │   ├── animation\n│   │   ├── mixins\n│   │   ├── reset.css\n│   │   ├── variables-jdb.scss\n│   │   ├── variables-jddkh.scss\n│   │   ├── variables-jdt.scss\n│   │   └── variables.scss\n│   └── utils\n│       ├── is.ts\n│       └── style.ts\n├── tsconfig.json\n├── vite.config.build.css.ts\n└── vite.config.ts\n")])])]),t("p",[s._v("vite-plugin-solid这个文件，由于我们在taro侧需要用到自己的babel，而这个babel也能兼容web端，所以不需要再引入官方的babel-preset-solid了。而nutui.solid.build.ts的入口文件，是打包入口文件，"),t("strong",[s._v("目前每次新增一个新的组件，都需要手动在这里面export一个新的组件出去")]),s._v("，也是不够自动化，后续会改为脚本自动生成。")]),s._v(" "),t("h1",{attrs:{id:"icon"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#icon"}},[s._v("#")]),s._v(" icon")]),s._v(" "),t("p",[s._v("关于icon，官方是使用的iconFont的形式，对于这种形式，我总感觉现在有更好的方案，不知道jym是否有建议呢？可能我会参考一下iconify的实现。")]),s._v(" "),t("h1",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),t("p",[s._v("以上是该仓库的一些简要介绍，目前的组件有106个，button组件我是作为示例实现出来了。后面的nutui的组件翻译，凭一个人的力量太有限了😭，而且基建的架构还有许多要完善，icon也还未开始，组件侧的很多示例都需要依赖这个icon，目前button其实也有，不过写死了个svg上去，后面还需要修改。如果有喜欢solid的jym，来拓展一下solid的生态吧👏👏👏")])])}),[],!1,null,null,null);t.default=e.exports}}]);